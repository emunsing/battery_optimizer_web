import math
import pandas as pd
import pulp as pl
import click
import numpy as np

def build_and_export_pulp(input_df: pd.DataFrame,
                          batt_rt_eff=0.85,
                          batt_e_max=13.5,
                          batt_p_max=5,
                          dt=1.0,
                          filename="model_pulp.mps"):
    input_df = input_df[['load', 'solar', 'px_buy', 'px_sell']]
    T = list(input_df.index)  # time steps
    
    # Parameters
    oneway_eff = math.sqrt(batt_rt_eff)
    inv_oneway_eff = 1.0 / oneway_eff
    backup_reserve = 0.2
    e_min = backup_reserve * batt_e_max
    E_0 = e_min

    # Problem
    prob = pl.LpProblem("BatteryGrid", pl.LpMinimize)

    # Variables
    P_charge   = pl.LpVariable.dicts("P_batt_charge",   T, lowBound=-batt_p_max, upBound=0)
    P_discharge= pl.LpVariable.dicts("P_batt_discharge",T, lowBound=0,        upBound=batt_p_max)
    P_buy      = pl.LpVariable.dicts("P_grid_buy",      T, lowBound=0)
    P_sell     = pl.LpVariable.dicts("P_grid_sell",     T, lowBound=None,     upBound=0)
    E_state    = pl.LpVariable.dicts("E",                list(range(len(T)+1)),
                                     lowBound=e_min,     upBound=batt_e_max)

    # Objective
    prob += pl.lpSum([
        P_sell[t] * input_df.loc[t, "px_sell"]
      + P_buy[t]  * input_df.loc[t, "px_buy"]
      for t in T
    ])

    # Constraints
    # Initial SOC
    prob += E_state[0] == E_0

    # Energy dynamics & power balance at each step
    for i, t in enumerate(T):
        # E[i+1] = E[i] - (charge*eff + discharge/eff)*dt
        prob += ( E_state[i+1]
                == E_state[i]
                   - (P_charge[t] * oneway_eff
                      + P_discharge[t] * inv_oneway_eff) * dt )
        # Power balance: charge + discharge + buy + sell + net load = 0
        prob += ( P_charge[t]
                + P_discharge[t]
                + P_buy[t]
                + P_sell[t]
                - input_df.loc[t, "load"]
                + input_df.loc[t, "solar"]
                == 0 )

    # Export to MPS
    prob.writeMPS(filename)
    print(f"Wrote PuLP MPS to {filename}")


import pathlib

data_root = pathlib.Path('data')
output_root = pathlib.Path('mps_files')


input_fnames = [
    'tmp_full_noindex.csv',
    'tmp_half_noindex.csv',
    'tmp_quarter_noindex.csv',
    'tmp_fivehundred_rows_noindex.csv',
    'tmp_onethousand_noindex.csv',
]

@click.command()
@click.argument('data_root', type=click.Path())
@click.argument('output_root', type=click.Path())
@click.option("--filter", '-f', 'input_filter', type=str, default="*.csv",
              help="Glob pattern to filter input files.")
def build_mps_files(data_root, output_root, input_filter):
    """
    Take index-free CSV files generated by Battery_Scratch.ipynb and convert them to problem
    MPS files for CLP. Add a second set of files to test warm-starting, 
    based on adding noise to the initial problem.

    Input CSV files should have the following columns: load,solar,px_buy,px_sell
    
    Load and solar are in kW, px_buy and px_sell are in $/kWh.
    """
    data_root = pathlib.Path(data_root)
    output_root = pathlib.Path(output_root)
    output_root.mkdir(parents=True, exist_ok=True)

    input_fnames = data_root.glob(input_filter)

#     input_fnames = [
#     'tmp_full_noindex.csv',
#     'tmp_half_noindex.csv',
#     'tmp_quarter_noindex.csv',
#     'tmp_fivehundred_rows_noindex.csv',
#     'tmp_onethousand_noindex.csv',
# ]

    for f in input_fnames:
        input_f = f
        output_f = output_root / (input_f.stem + '.mps')
        input_df = pd.read_csv(input_f)
        build_and_export_pulp(input_df, filename=output_f)

        # Add noise as a reference for warm-starting
        input_df['load'] = (input_df['load'] + np.random.randn(input_df["load"].shape[0])).clip(lower=0.01).rolling(window=3, center=True).mean().ffill().bfill() 
        input_df['solar'] = input_df['solar'] * 1.5
        build_and_export_pulp(input_df, filename=output_root / (input_f.stem + '_warmstart.mps'))


if __name__ == "__main__":
    build_mps_files()